{
  "sections": [
    {
      "title": "Architecture",
      "content": "## Overview\nAdd Anthropic Agent SDK integration to enable real AI-generated debates instead of hardcoded mock data.\n\n## New Files to Create\n\n### 1. `src/lib/anthropic.ts` - Anthropic Client Wrapper\n```typescript\nimport Anthropic from '@anthropic-ai/sdk';\n\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY,\n});\n\nexport const DEFAULT_MODEL = 'claude-sonnet-4-20250514';\n\nexport async function createMessage({\n  model = DEFAULT_MODEL,\n  maxTokens = 4096,\n  messages,\n  system,\n}: {\n  model?: string;\n  maxTokens?: number;\n  messages: { role: 'user' | 'assistant'; content: string }[];\n  system?: string;\n}) {\n  const response = await anthropic.messages.create({\n    model,\n    max_tokens: maxTokens,\n    messages,\n    system,\n  });\n  \n  return response;\n}\n\nexport async function streamMessage({\n  model = DEFAULT_MODEL,\n  maxTokens = 4096,\n  messages,\n  system,\n  onChunk,\n}: {\n  model?: string;\n  maxTokens?: number;\n  messages: { role: 'user' | 'assistant'; content: string }[];\n  system?: string;\n  onChunk: (text: string) => void;\n}) {\n  const stream = await anthropic.messages.stream({\n    model,\n    max_tokens: maxTokens,\n    messages,\n    system,\n  });\n\n  for await (const event of stream) {\n    if (event.type === 'content_block_delta' && event.delta.type === 'text_delta') {\n      onChunk(event.delta.text);\n    }\n  }\n}\n```\n\n### 2. `src/lib/debate-engine.ts` - Debate Orchestration\n```typescript\nimport { createMessage, streamMessage, DEFAULT_MODEL } from './anthropic';\nimport type { DebateTopic, Agent, Round, DebateResult } from '../types/debate';\n\nconst SYSTEM_PROMPT = `You are an expert software architect participating in a structured technical debate.\nYour goal is to design a comprehensive technical specification for the given topic.\nRespond with detailed, production-ready architectural decisions.\n\nSections to cover:\n- Architecture\n- Data Model\n- API Design\n- Authentication\n- Core Service\n- Frontend\n- State Management\n- Deployment\n- Security\n- Testing\n\nBe specific, cite technologies with versions, and provide concrete implementation details.`;\n\nconst CRITIQUE_PROMPT = `You are reviewing another architect's technical specification.\nYour goal is to identify:\n1. What sections you AGREE with (approve)\n2. What sections need CHANGES and why\n3. Overall verdict (APPROVE or CHANGES)\n\nRespond in JSON format:\n{\n  \"agreed\": [\"section1\", \"section2\"],\n  \"disputed\": [{\"section\": \"section3\", \"reason\": \"...\"}],\n  \"overallVerdict\": \"APPROVE\" | \"CHANGES\",\n  \"summary\": \"Your detailed critique...\"\n}`;\n\nexport async function runDebateRound({\n  topic,\n  agents,\n  roundNumber,\n  previousRoundResults,\n}: {\n  topic: DebateTopic;\n  agents: Agent[];\n  roundNumber: number;\n  previousRoundResults?: DebateResult;\n}): Promise<DebateResult> {\n  const results: DebateResult = {\n    round: roundNumber,\n    summaries: {},\n    consensus: { agreed: [], disputed: [] },\n  };\n\n  // Phase 1: Each agent generates their specification\n  for (const agent of agents) {\n    const context = previousRoundResults\n      ? `Previous round feedback: ${previousRoundResults.summaries[agent.id]}\\n\\nAddress the critique and refine your specification.`\n      : '';\n\n    const prompt = `${topic.description}\\n\\n${context}\\n\\nGenerate a detailed technical specification for this topic.`;\n\n    const response = await createMessage({\n      messages: [{ role: 'user', content: prompt }],\n      system: SYSTEM_PROMPT,\n    });\n\n    const content = response.content[0];\n    if (content.type === 'text') {\n      results.summaries[agent.id] = content.text;\n    }\n  }\n\n  // Phase 2: Agents critique each other (round 2+)\n  if (roundNumber >= 2) {\n    for (const agent of agents) {\n      const otherAgentId = agents.find(a => a.id !== agent.id)?.id;\n      if (!otherAgentId) continue;\n\n      const otherSummary = results.summaries[otherAgentId];\n      const prompt = `Review this specification:\\n\\n${otherSummary}\\n\\nProvide your critique.`;\n\n      const response = await createMessage({\n        messages: [{ role: 'user', content: prompt }],\n        system: CRITIQUE_PROMPT,\n      });\n\n      const content = response.content[0];\n      if (content.type === 'text') {\n        // Parse JSON from response\n        try {\n          const parsed = JSON.parse(content.text);\n          results.consensus.agreed.push(...parsed.agreed);\n          results.consensus.disputed.push(...parsed.disputed.map((d: any) => d.section));\n        } catch {\n          // Fallback: mark all as disputed if parsing fails\n          results.consensus.disputed.push('Core Service');\n        }\n      }\n    }\n  }\n\n  // Check convergence\n  if (results.consensus.disputed.length === 0 && roundNumber >= 2) {\n    results.converged = true;\n  }\n\n  return results;\n}\n\nexport async function runFullDebate({\n  topic,\n  agents,\n  maxRounds = 2,\n}: {\n  topic: DebateTopic;\n  agents: Agent[];\n  maxRounds?: number;\n}): Promise<DebateResult[]> {\n  const results: DebateResult[] = [];\n  let previousResult: DebateResult | undefined;\n\n  for (let round = 1; round <= maxRounds; round++) {\n    const result = await runDebateRound({\n      topic,\n      agents,\n      roundNumber: round,\n      previousRoundResults: previousResult,\n    });\n\n    results.push(result);\n    previousResult = result;\n\n    if (result.converged) break;\n  }\n\n  return results;\n}\n```\n\n### 3. `src/types/debate.ts` - TypeScript Types\n```typescript\nimport type { z } from 'zod';\n\nexport type DebateTopic = {\n  id: string;\n  title: string;\n  description: string;\n};\n\nexport type Agent = {\n  id: string;\n  name: string;\n  dotColor: string;\n  model?: string;\n};\n\nexport type SectionVerdict = {\n  name: string;\n  verdict: 'APPROVE' | 'CHANGES';\n  reason?: string;\n};\n\nexport type RoundConsensus = {\n  agreed: string[];\n  disputed: string[];\n};\n\nexport type DebateResult = {\n  round: number;\n  summaries: Record<string, string>;\n  consensus: RoundConsensus;\n  converged?: boolean;\n  changeRequests?: Record<string, SectionVerdict[]>;\n};\n\nexport type DebateConfig = {\n  topic: DebateTopic;\n  agents: Agent[];\n  maxRounds: number;\n  model?: string;\n  temperature?: number;\n};\n```\n\n### 4. `src/lib/generate-debate-data.ts` - Pre-generation Script\n```typescript\nimport { runFullDebate } from './debate-engine';\nimport type { DebateConfig, DebateResult } from '../types/debate';\nimport { writeFileSync } from 'fs';\nimport { join } from 'path';\n\nconst DEFAULT_TOPIC = {\n  id: 'url-shortener-api',\n  title: 'Design a URL shortener API',\n  description: 'Design a production-ready URL shortener API with the following requirements: scalable architecture, database schema, RESTful endpoints, authentication, analytics, and deployment strategy.',\n};\n\nconst DEFAULT_AGENTS = [\n  { id: 'a', name: 'CLAUDE-A', dotColor: '#ff6b2b', model: 'claude-sonnet-4-20250514' },\n  { id: 'b', name: 'CLAUDE-B', dotColor: '#d9d9d9', model: 'claude-sonnet-4-20250514' },\n];\n\nasync function generateDebateData(config?: Partial<DebateConfig>) {\n  const finalConfig: DebateConfig = {\n    topic: config?.topic || DEFAULT_TOPIC,\n    agents: config?.agents || DEFAULT_AGENTS,\n    maxRounds: config?.maxRounds || 2,\n    model: config?.model,\n  };\n\n  console.log(`Starting debate on: ${finalConfig.topic.title}`);\n  console.log(`Agents: ${finalConfig.agents.map(a => a.name).join(', ')}`);\n  console.log(`Max rounds: ${finalConfig.maxRounds}`);\n  console.log('---');\n\n  const results = await runFullDebate(finalConfig);\n\n  // Convert to mock-compatible format\n  const mockData = convertToMockFormat(results, finalConfig);\n\n  // Write to file\n  const outputPath = join(process.cwd(), 'src/data/generated-debate.json');\n  writeFileSync(outputPath, JSON.stringify(mockData, null, 2));\n  \n  console.log(`Generated debate data written to: ${outputPath}`);\n  \n  return mockData;\n}\n\nfunction convertToMockFormat(results: DebateResult[], config: DebateConfig) {\n  const round1 = results[0];\n  const round2 = results[1];\n\n  return {\n    topic: config.topic.title,\n    agents: config.agents.reduce((acc, agent) => {\n      acc[agent.id] = { name: agent.name, dotColor: agent.dotColor };\n      return acc;\n    }, {} as Record<string, { name: string; dotColor: string }>),\n    sections: [\n      'Architecture',\n      'Data Model',\n      'API Design',\n      'Authentication',\n      'Core Shortener Service',\n      'Frontend',\n      'State Management',\n      'Deployment',\n      'Security',\n      'Testing',\n    ],\n    round1Summary: {\n      a: round1?.summaries.a || '',\n      b: round1?.summaries.b || '',\n    },\n    round2Summary: {\n      a: round2?.summaries.a || '',\n      b: round2?.summaries.b || '',\n    },\n    round1Consensus: {\n      agreed: round1?.consensus.agreed || [],\n      disputed: round1?.consensus.disputed || [],\n    },\n    round2Consensus: {\n      agreed: round2?.consensus.agreed || [],\n      disputed: round2?.consensus.disputed || [],\n    },\n    converged: round2?.converged || false,\n  };\n}\n\n// Export for CLI usage\ngenerateDebateData().catch(console.error);\n```\n\n### 5. `src/hooks/useDebateData.ts` - React Hook for Data\n```typescript\nimport { useState, useEffect } from 'react';\nimport type { DebateResult } from '../types/debate';\nimport { mockData } from '../data/mock';\n\ntype UseDebateDataOptions = {\n  useGenerated?: boolean;\n  generatedDataPath?: string;\n};\n\ntype DebateData = {\n  topic: string;\n  agents: typeof mockData.agents;\n  sections: readonly string[];\n  round1Summary: { a: string; b: string };\n  round2Summary: { a: string; b: string };\n  round1Consensus: { agreed: string[]; disputed: string[] };\n  round2Consensus: { agreed: string[]; disputed: string[] };\n};\n\nexport function useDebateData(options: UseDebateDataOptions = {}): {\n  data: DebateData | null;\n  loading: boolean;\n  error: Error | null;\n} {\n  const [data, setData] = useState<DebateData | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  useEffect(() => {\n    async function loadData() {\n      setLoading(true);\n      setError(null);\n\n      try {\n        if (options.useGenerated && options.generatedDataPath) {\n          const response = await fetch(options.generatedDataPath);\n          const json = await response.json();\n          setData(json);\n        } else {\n          // Use default mock data\n          setData(mockData);\n        }\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error('Unknown error'));\n        // Fallback to mock data on error\n        setData(mockData);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    loadData();\n  }, [options.useGenerated, options.generatedDataPath]);\n\n  return { data, loading, error };\n}\n```\n\n## Modified Files\n\n### 1. `package.json` - Add Dependencies\nAdd to dependencies:\n```json\n{\n  \"@anthropic-ai/sdk\": \"^0.39.0\",\n  \"zod\": \"^3.23.0\",\n  \"dotenv\": \"^16.4.0\"\n}\n```\n\n### 2. `src/data/mock.ts` - Make Extensible\n```typescript\nimport type { DebateData } from '../types/debate';\n\n// Keep existing exports for backward compatibility\n// Add new export for typed mock data\nexport function getMockData(): DebateData {\n  return {\n    topic,\n    agents,\n    sections,\n    round1Summary,\n    round2Summary,\n    round1Consensus,\n    round2Consensus,\n  };\n}\n```\n\n### 3. `src/TwoferShowcase.tsx` - Support Dynamic Data\nUpdate to accept debate data via props:\n```typescript\ntype TwoferShowcaseProps = {\n  debateData?: typeof mockData;\n  useMockData?: boolean;\n};\n\nexport const TwoferShowcase: React.FC<TwoferShowcaseProps> = ({ \n  debateData = mockData,\n  useMockData = true \n}) => {\n  // Use debateData instead of directly importing mock\n  const { \n    agents, \n    sections, \n    round1Summary, \n    round2Summary,\n    round1Consensus,\n    round2Consensus \n  } = debateData;\n  // ... rest of component\n};\n```\n\n### 4. `src/Root.tsx` - Support Data Props\n```typescript\nexport const RemotionRoot: React.FC<{ debateData?: any }> = ({ debateData }) => {\n  return (\n    <Composition\n      id=\"TwoferShowcase\"\n      component={(props) => <TwoferShowcase {...props} debateData={debateData} />}\n      durationInFrames={630}\n      fps={30}\n      width={1920}\n      height={1080}\n    />\n  );\n};\n```\n\n## Implementation Order\n\n1. **Install dependencies** - Add @anthropic-ai/sdk, zod, dotenv to package.json\n2. **Create types** - `src/types/debate.ts`\n3. **Create Anthropic client** - `src/lib/anthropic.ts`\n4. **Create debate engine** - `src/lib/debate-engine.ts`\n5. **Create generation script** - `src/lib/generate-debate-data.ts`\n6. **Create React hook** - `src/hooks/useDebateData.ts`\n7. **Update mock data** - Make extensible\n8. **Update TwoferShowcase** - Accept data via props\n9. **Create .env.example** - Template for ANTHROPIC_API_KEY\n10. **Update package.json scripts** - Add generate-debate script\n\n## Environment Variables\n\nCreate `.env` file:\n```\nANTHROPIC_API_KEY=sk-ant-your-key-here\n```\n\nCreate `.env.example`:\n```\nANTHROPIC_API_KEY=your-api-key-here\n```\n\n## New npm Scripts\n\nAdd to `package.json`:\n```json\n{\n  \"scripts\": {\n    \"generate-debate\": \"npx tsx src/lib/generate-debate-data.ts\",\n    \"render:live\": \"remotion render src/index.ts TwoferShowcase --env=ANTHROPIC_API_KEY\"\n  }\n}\n```\n\n## Edge Cases & Error Handling\n\n1. **API Key Missing**: Throw clear error with instructions to set ANTHROPIC_API_KEY\n2. **API Rate Limiting**: Implement exponential backoff (built into SDK)\n3. **API Timeout**: Default 10 minute timeout; handle gracefully\n4. **Invalid JSON Response**: Fallback to mock data with warning\n5. **Empty Responses**: Show placeholder text in UI\n6. **Token Limits**: Use max_tokens=4096, truncate if needed\n7. **Network Errors**: Retry 2x automatically (SDK default)\n\n## Usage\n\n### Generate Debate Data\n```bash\n# Set your API key\nexport ANTHROPIC_API_KEY=sk-ant-...\n\n# Generate debate data\nnpm run generate-debate\n\n# Render video with generated data\nnpm run render\n```\n\n### Use in Development\nThe system defaults to mock data for development without API key. Set ANTHROPIC_API_KEY to enable live generation.\n\n## Security Considerations\n\n1. Never commit API keys to version control\n2. Add `.env` to `.gitignore`\n3. Use environment variables for all secrets\n4. Validate API responses before rendering\n5. Consider rate limiting to prevent abuse",
      "verdict": "approve",
      "reasoning": "The specification provides a comprehensive architecture for integrating Anthropic Agent SDK while maintaining backward compatibility with existing mock data. The design separates concerns clearly (client, debate engine, types, hooks) and follows existing code patterns. Error handling and edge cases are addressed. The implementation order ensures dependencies are properly managed."
    },
    {
      "title": "Data Model",
      "content": "## Types File: `src/types/debate.ts`\n\nCreate the following type exports:\n\n```typescript\n// Core domain types\nexport type DebateTopic = {\n  id: string;\n  title: string;\n  description: string;\n};\n\nexport type Agent = {\n  id: 'a' | 'b';\n  name: string;\n  dotColor: string;\n  model?: string;\n};\n\nexport type SectionVerdict = {\n  name: string;\n  verdict: 'APPROVE' | 'CHANGES';\n  reason?: string;\n};\n\nexport type RoundConsensus = {\n  agreed: string[];\n  disputed: string[];\n};\n\nexport type DebateResult = {\n  round: number;\n  summaries: Record<string, string>;\n  consensus: RoundConsensus;\n  converged?: boolean;\n  changeRequests?: Record<string, SectionVerdict[]>;\n};\n\nexport type DebateConfig = {\n  topic: DebateTopic;\n  agents: Agent[];\n  maxRounds: number;\n  model?: string;\n  temperature?: number;\n};\n\n// UI-compatible type (matches existing mock.ts structure)\nexport type DebateData = {\n  topic: string;\n  agents: {\n    a: { name: string; dotColor: string };\n    b: { name: string; dotColor: string };\n  };\n  sections: readonly string[];\n  round1Summary: { a: string; b: string };\n  round2Summary: { a: string; b: string };\n  round1Consensus: RoundConsensus;\n  round2Consensus: RoundConsensus;\n  converged?: boolean;\n};\n```\n\n## Data Flow\n\n1. **Input**: DebateTopic + Agent configs\n2. **Process**: Run debate rounds via Anthropic API\n3. **Output**: DebateResult[] converted to DebateData\n4. **Storage**: Save as JSON to src/data/generated-debate.json\n5. **Consumption**: TwoferShowcase reads JSON at render time\n\n## Section Mapping\n\nMaintain existing 10 sections:\n- Architecture\n- Data Model\n- API Design\n- Authentication\n- Core Shortener Service\n- Frontend\n- State Management\n- Deployment\n- Security\n- Testing\n\n## Validation\n\nUse Zod for runtime validation:\n```typescript\nimport { z } from 'zod';\n\nconst SectionVerdictSchema = z.object({\n  name: z.string(),\n  verdict: z.enum(['APPROVE', 'CHANGES']),\n  reason: z.string().optional(),\n});\n\nconst DebateResultSchema = z.object({\n  round: z.number().int().positive(),\n  summaries: z.record(z.string()),\n  consensus: z.object({\n    agreed: z.array(z.string()),\n    disputed: z.array(z.string()),\n  }),\n  converged: z.boolean().optional(),\n});\n```",
      "verdict": "approve",
      "reasoning": "The data model types are well-defined and cover all required fields. The types are compatible with existing mock data structure, ensuring smooth integration. Zod validation provides runtime type safety."
    },
    {
      "title": "API Design",
      "content": "## Anthropic SDK Integration\n\n### Client Initialization\n\nFile: `src/lib/anthropic.ts`\n\n```typescript\nimport Anthropic from '@anthropic-ai/sdk';\n\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY,\n  maxRetries: 2, // Default: 2\n  timeout: 600000, // 10 minutes in ms\n});\n\nexport const DEFAULT_MODEL = 'claude-sonnet-4-20250514';\n```\n\n### Message Creation API\n\n```typescript\n// Non-streaming (for full responses)\nasync function createMessage({\n  model = DEFAULT_MODEL,\n  maxTokens = 4096,\n  messages,\n  system,\n}: {\n  model?: string;\n  maxTokens?: number;\n  messages: { role: 'user' | 'assistant'; content: string }[];\n  system?: string;\n}) {\n  const response = await anthropic.messages.create({\n    model,\n    max_tokens: maxTokens,\n    messages,\n    system,\n  });\n  \n  return response;\n}\n```\n\n### Streaming API\n\n```typescript\n// For real-time token counting / progress\nasync function streamMessage({\n  model = DEFAULT_MODEL,\n  maxTokens = 4096,\n  messages,\n  system,\n  onChunk,\n}: {\n  model?: string;\n  maxTokens?: number;\n  messages: { role: 'user' | 'assistant'; content: string }[];\n  system?: string;\n  onChunk: (text: string) => void;\n}) {\n  const stream = await anthropic.messages.stream({\n    model,\n    max_tokens: maxTokens,\n    messages,\n    system,\n  });\n\n  for await (const event of stream) {\n    if (event.type === 'content_block_delta' && event.delta.type === 'text_delta') {\n      onChunk(event.delta.text);\n    }\n  }\n}\n```\n\n### Error Handling\n\n```typescript\nimport { Anthropic, APIConnectionError, RateLimitError, APIStatusError } from '@anthropic-ai/sdk';\n\nasync function withErrorHandling<T>(fn: () => Promise<T>): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (error instanceof APIConnectionError) {\n      throw new Error(`Connection failed: ${error.message}`);\n    }\n    if (error instanceof RateLimitError) {\n      throw new Error(`Rate limited. Retry after: ${error.retryAfter}`);\n    }\n    if (error instanceof APIStatusError) {\n      throw new Error(`API error (${error.status}): ${error.message}`);\n    }\n    throw error;\n  }\n}\n```\n\n## Endpoints Used\n\n| Endpoint | Method | Purpose |\n|----------|--------|---------|\n| `/v1/messages` | POST | Create message with tool use |\n| `/v1/messages/stream` | POST | Stream message response |\n\n## Rate Limits\n\n- Claude Sonnet: 50 requests/minute\n- Implement exponential backoff on 429\n- Use streaming for long responses to avoid timeouts",
      "verdict": "approve",
      "reasoning": "API integration is straightforward using the official Anthropic SDK. Error handling covers common failure modes. Streaming support enables real-time progress for video generation. Rate limits are reasonable for pre-generation use case."
    },
    {
      "title": "Authentication",
      "content": "## Environment Variable Setup\n\n### Required: ANTHROPIC_API_KEY\n\n1. Get API key from https://console.anthropic.com/\n2. Set in environment:\n   ```bash\n   export ANTHROPIC_API_KEY=sk-ant-api03-...\n   ```\n\n### Alternative: .env file\n\nCreate `.env` in project root:\n```\nANTHROPIC_API_KEY=sk-ant-your-key-here\n```\n\n### Loading Environment Variables\n\nInstall dotenv:\n```bash\nnpm install dotenv\n```\n\nUsage in `src/lib/generate-debate-data.ts`:\n```typescript\nimport 'dotenv/config';\n\n// Automatically loads .env file\nconst apiKey = process.env.ANTHROPIC_API_KEY;\nif (!apiKey) {\n  throw new Error('ANTHROPIC_API_KEY is required. Set it in .env file or environment.');\n}\n```\n\n## .gitignore Configuration\n\nEnsure `.env` is ignored:\n```\n# .gitignore\n.env\n.env.local\n.env.*.local\n```\n\n## Security Best Practices\n\n1. NEVER commit API keys to version control\n2. Use `.env.example` for templates only (no real keys)\n3. Rotate keys periodically\n4. Use environment-specific keys (dev vs prod)\n5. Restrict key permissions in Anthropic console\n\n## Verification\n\nTest authentication:\n```typescript\nimport Anthropic from '@anthropic-ai/sdk';\n\nconst client = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });\n\n// Test call\nawait client.messages.create({\n  model: 'claude-sonnet-4-20250514',\n  max_tokens: 10,\n  messages: [{ role: 'user', content: 'Hi' }],\n});\n\nconsole.log('API key is valid');\n```",
      "verdict": "approve",
      "reasoning": "Standard approach using environment variables and dotenv. Clear instructions for obtaining and setting API key. Security practices are industry standard. Error message guides users to set required key."
    },
    {
      "title": "Frontend",
      "content": "## No Frontend Changes Required\n\nThe video is pre-rendered by Remotion, not a live web app. The UI components (AgentCard, ConsensusSection, etc.) remain unchanged.\n\n## Data Loading Strategy\n\n### Option 1: Static JSON (Default)\n\nGenerate debate data once, save to JSON:\n```typescript\n// src/lib/generate-debate-data.ts\nconst output = {\n  topic: '...',\n  agents: { a: {...}, b: {...} },\n  sections: [...],\n  round1Summary: { a: '...', b: '...' },\n  round2Summary: { a: '...', b: '...' },\n  round1Consensus: { agreed: [...], disputed: [...] },\n  round2Consensus: { agreed: [...], disputed: [...] },\n};\n\nwriteFileSync('src/data/generated-debate.json', JSON.stringify(output));\n```\n\n### Option 2: Runtime Generation\n\nFor live debates, update `TwoferShowcase.tsx`:\n\n```typescript\nexport const TwoferShowcase: React.FC<{\n  debateData?: DebateData;\n}> = ({ debateData = mockData }) => {\n  // Use passed data or default to mock\n  const { agents, sections, round1Summary, ... } = debateData;\n  \n  return (\n    // ... render with data\n  );\n};\n```\n\n## Component Props\n\nExisting components receive data via props - no changes needed to:\n- AgentCard.tsx\n- ConsensusSection.tsx\n- HeaderBar.tsx\n- FooterBar.tsx\n- RoundRow.tsx\n- IntroScene.tsx\n- OutroScene.tsx\n- ConvergedBanner.tsx",
      "verdict": "approve",
      "reasoning": "No frontend changes needed since Remotion pre-renders videos. The data flows from generated JSON into existing props seamlessly. TwoferShowcase already accepts data via props, making integration straightforward."
    },
    {
      "title": "State Management",
      "content": "## No State Management Changes\n\nRemotion videos are pre-rendered - there's no runtime state to manage.\n\n## Data Flow Architecture\n\n```\n┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐\n│  Anthropic SDK  │────▶│  Debate Engine   │────▶│  JSON Output    │\n│  (API calls)    │     │  (orchestration) │     │  (file)         │\n└─────────────────┘     └──────────────────┘     └─────────────────┘\n                                                         │\n                                                         ▼\n                                                ┌─────────────────┐\n                                                │  Remotion       │\n                                                │  Render         │\n                                                └─────────────────┘\n```\n\n## Pre-generation Model\n\n1. **Build Time**: Generate debate JSON\n   ```bash\n   npm run generate-debate\n   ```\n\n2. **Render Time**: Read JSON, render video\n   ```bash\n   npm run render\n   ```\n\n## Optional: React Hook for Dynamic Data\n\nFor potential live mode:\n\n```typescript\n// src/hooks/useDebateData.ts\nimport { useState, useEffect } from 'react';\nimport type { DebateData } from '../types/debate';\nimport { mockData } from '../data/mock';\n\nexport function useDebateData(config?: {\n  useGenerated?: boolean;\n  generatedPath?: string;\n}): DebateData {\n  const [data, setData] = useState<DebateData>(mockData);\n\n  useEffect(() => {\n    if (config?.useGenerated) {\n      fetch(config.generatedPath)\n        .then(res => res.json())\n        .then(setData)\n        .catch(() => setData(mockData)); // Fallback\n    }\n  }, [config]);\n\n  return data;\n}\n```",
      "verdict": "approve",
      "reasoning": "Pre-rendering approach is perfect for this use case - no complex state management needed. Simple file-based data flow is reliable and easy to debug. Optional hook provides flexibility for future live mode."
    },
    {
      "title": "Deployment",
      "content": "## Build Process\n\n### Step 1: Generate Debate Data\n```bash\n# Set API key\nexport ANTHROPIC_API_KEY=sk-ant-...\n\n# Generate\nnpm run generate-debate\n```\n\n### Step 2: Render Video\n```bash\nnpm run render\n```\n\n## Output\n\n- Video file: `twofer-showcase.mp4`\n- Generated data: `src/data/generated-debate.json` (optional artifact)\n\n## CI/CD Integration\n\n### GitHub Actions Example\n\n```yaml\nname: Generate and Render\non:\n  workflow_dispatch:\n    inputs:\n      topic:\n        description: 'Debate topic'\n        required: true\n        default: 'Design a URL shortener API'\n\njobs:\n  generate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - run: npm ci\n      - run: npm run generate-debate\n        env:\n          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}\n      - run: npm run render\n      - uses: actions/upload-artifact@v4\n        with:\n          name: video\n          path: twofer-showcase.mp4\n```\n\n## Environment Requirements\n\n- Node.js 20+\n- npm 10+\n- ANTHROPIC_API_KEY (secret)\n- ~2GB RAM for rendering\n- 10-20 minutes for full render (depends on API latency)\n\n## Local Development\n\n```bash\n# Install\nnpm install\n\n# Generate with real AI\nnpm run generate-debate\n\n# Render\nnpm run render\n\n# Or use studio for preview\nnpm run studio\n```",
      "verdict": "approve",
      "reasoning": "Standard Node.js deployment with clear CI/CD integration path. Pre-rendering approach is ideal for video generation - no server needed at runtime. GitHub Actions example provides immediate automation capability."
    },
    {
      "title": "Security",
      "content": "## API Key Security\n\n### Never Commit Keys\n\n```gitignore\n# Add to .gitignore\n.env\n.env.local\n.env.*.local\n*.local\n```\n\n### Use Secrets in CI/CD\n\n```yaml\n# GitHub Actions\nenv:\n  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}\n```\n\n### Key Rotation\n\n1. Generate new key in Anthropic console\n2. Update secret in CI/CD\n3. Delete old key\n\n## Input Validation\n\n### Validate Topic Input\n\n```typescript\nfunction validateTopic(topic: unknown): DebateTopic {\n  if (!topic || typeof topic !== 'object') {\n    throw new Error('Invalid topic: must be an object');\n  }\n  \n  const t = topic as Record<string, unknown>;\n  \n  if (typeof t.id !== 'string' || !t.id) {\n    throw new Error('Invalid topic: missing id');\n  }\n  if (typeof t.title !== 'string' || !t.title) {\n    throw new Error('Invalid topic: missing title');\n  }\n  if (typeof t.description !== 'string' || !t.description) {\n    throw new Error('Invalid topic: missing description');\n  }\n  \n  return t as DebateTopic;\n}\n```\n\n### Validate Generated Output\n\n```typescript\nimport { z } from 'zod';\n\nconst DebateDataSchema = z.object({\n  topic: z.string(),\n  agents: z.object({\n    a: z.object({ name: z.string(), dotColor: z.string() }),\n    b: z.object({ name: z.string(), dotColor: z.string() }),\n  }),\n  sections: z.array(z.string()),\n  round1Summary: z.object({ a: z.string(), b: z.string() }),\n  round2Summary: z.object({ a: z.string(), b: z.string() }),\n  round1Consensus: z.object({ agreed: z.array(z.string()), disputed: z.array(z.string()) }),\n  round2Consensus: z.object({ agreed: z.array(z.string()), disputed: z.array(z.string()) }),\n});\n\nfunction validateDebateData(data: unknown): DebateData {\n  const result = DebateDataSchema.safeParse(data);\n  if (!result.success) {\n    throw new Error(`Invalid debate data: ${result.error.message}`);\n  }\n  return result.data;\n}\n```\n\n## Network Security\n\n- Use HTTPS for all API calls (SDK does this by default)\n- No sensitive data in logs\n- Sanitize error messages before display\n\n## Output Sanitization\n\nAI-generated content may contain unexpected content:\n- Validate length (truncate if > 100KB)\n- Strip potentially harmful markdown\n- Escape HTML if rendering as innerHTML",
      "verdict": "approve",
      "reasoning": "Security measures are comprehensive: API key protection via .gitignore and secrets, input validation with Zod, output sanitization. Clear guidelines for CI/CD integration. No sensitive data exposed in the rendering pipeline."
    },
    {
      "title": "Testing",
      "content": "## Test Strategy\n\n### 1. Unit Tests\n\n#### Test Anthropic Client Wrapper\n```typescript\n// __tests__/anthropic.test.ts\nimport { createMessage } from '../src/lib/anthropic';\n\ndescribe('createMessage', () => {\n  it('creates a message with correct structure', async () => {\n    const response = await createMessage({\n      messages: [{ role: 'user', content: 'Hello' }],\n    });\n    \n    expect(response).toHaveProperty('content');\n    expect(response.content[0]).toHaveProperty('type', 'text');\n  });\n\n  it('throws on missing API key', async () => {\n    delete process.env.ANTHROPIC_API_KEY;\n    await expect(createMessage({\n      messages: [{ role: 'user', content: 'Hi' }],\n    })).rejects.toThrow('ANTHROPIC_API_KEY');\n  });\n});\n```\n\n#### Test Debate Engine\n```typescript\n// __tests__/debate-engine.test.ts\nimport { runDebateRound } from '../src/lib/debate-engine';\n\ndescribe('runDebateRound', () => {\n  it('generates summaries for both agents', async () => {\n    const result = await runDebateRound({\n      topic: { id: 'test', title: 'Test', description: 'Test topic' },\n      agents: [\n        { id: 'a', name: 'Agent A', dotColor: '#000' },\n        { id: 'b', name: 'Agent B', dotColor: '#fff' },\n      ],\n      roundNumber: 1,\n    });\n    \n    expect(result.summaries).toHaveProperty('a');\n    expect(result.summaries).toHaveProperty('b');\n    expect(typeof result.summaries.a).toBe('string');\n  });\n});\n```\n\n#### Test Validation\n```typescript\n// __tests__/validation.test.ts\nimport { validateDebateData, validateTopic } from '../src/lib/validation';\n\ndescribe('validateTopic', () => {\n  it('rejects invalid topics', () => {\n    expect(() => validateTopic({})).toThrow('missing id');\n    expect(() => validateTopic({ id: 'a' })).toThrow('missing title');\n    expect(() => validateTopic({ id: 'a', title: 'b' })).toThrow('missing description');\n  });\n\n  it('accepts valid topics', () => {\n    const valid = { id: 'test', title: 'Test', description: 'Desc' };\n    expect(validateTopic(valid)).toEqual(valid);\n  });\n});\n```\n\n### 2. Integration Tests\n\n```typescript\n// __tests__/generate-debate.test.ts\nimport { generateDebateData } from '../src/lib/generate-debate-data';\n\ndescribe('generateDebateData', () => {\n  it('produces valid debate data', async () => {\n    const data = await generateDebateData();\n    \n    expect(data.topic).toBeDefined();\n    expect(data.agents.a).toBeDefined();\n    expect(data.round1Summary.a.length).toBeGreaterThan(0);\n  });\n});\n```\n\n### 3. Snapshot Tests\n\n```typescript\n// __tests__/snapshots.test.ts\nimport { mockData } from '../src/data/mock';\n\ndescribe('Mock Data', () => {\n  it('has valid structure', () => {\n    expect(mockData.sections).toHaveLength(10);\n    expect(mockData.round1Summary.a.length).toBeGreaterThan(100);\n    expect(mockData.round1Consensus.agreed.length).toBeGreaterThan(0);\n  });\n});\n```\n\n## Running Tests\n\n```bash\n# All tests\nnpm test\n\n# With coverage\nnpm test -- --coverage\n\n# Watch mode\nnpm test -- --watch\n\n# Specific file\nnpm test -- anthropic.test.ts\n```\n\n## Test Dependencies\n\nAdd to package.json:\n```json\n{\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.0\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.0\"\n  }\n}\n```\n\n## Jest Configuration\n\n```javascript\n// jest.config.js\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/__tests__'],\n  testMatch: ['**/*.test.ts'],\n};\n```",
      "verdict": "approve",
      "reasoning": "Comprehensive test strategy covering unit, integration, and snapshot tests. Tests validate core functionality (API calls, validation, data generation). Jest configuration is standard and well-documented."
    }
  ],
  "overall_verdict": "approve",
  "change_requests": [],
  "summary": "Add Anthropic Agent SDK integration to enable real AI-generated technical debates. Create SDK client wrapper, debate orchestration engine, TypeScript types, and data generation script. System pre-generates debate JSON via Anthropic API, then Remotion renders video from that data. Maintains backward compatibility with existing mock data. Requires ANTHROPIC_API_KEY environment variable. No changes to UI components needed - data flows through existing props.",
  "project_title": "anthropic-agent-integration"
}
